package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
)

const versionTemplate = `// Code generated by gravity-development-toolkit. DO NOT EDIT.
package gravity

//go:generate go run ./developing/tools genversion

// Version ...
const Version = "ep02-%s (expirimental/prototyping)"
`

func genversion() {
	var (
		gitCmdName = "git"
		gitCmdArgs = []string{"rev-parse", "--verify", "HEAD"}
	)

	fmt.Println("genversion running...")
	checkCommand(gitCmdName)

	var log []byte
	var err error
	if log, err = exec.Command(gitCmdName, gitCmdArgs...).Output(); err != nil {
		fmt.Println(gitCmdName, "errored with:\n", err, "\n", string(log))
		os.Exit(1)
	}

	sha := string(log)
	val := sha[:6]
	fmt.Println("resolved value:", val)
	generateVersionFile(val)
}

func generateVersionFile(val string) {
	var outfile = resolveVersionFilepath()
	f, err := os.OpenFile(outfile, os.O_RDWR|os.O_CREATE, os.ModePerm)
	if err != nil {
		fmt.Println("unable to create \""+outfile+"\": ", err)
		os.Exit(1)
	}
	defer f.Close()

	f.Truncate(0)

	fmt.Println("writing to file \"" + outfile + "\"")
	_, err = f.WriteString(
		fmt.Sprintf(versionTemplate, val),
	)

	if err != nil {
		fmt.Println("unable to write to \""+outfile+"\": ", err)
		os.Exit(1)
	}
}

func resolveVersionFilepath() string {
	cwd, err := os.Getwd()
	if err != nil {
		fmt.Println("unable to resolve Gravity path:", err)
		os.Exit(1)
	}
	gravityRoot := filepath.Join(filepath.Dir(cwd), "gravity")
	versionFilepath := filepath.Join(gravityRoot, "version.go")

	if _, err := os.Stat(versionFilepath); err != nil {
		fmt.Println("unable to resolve \"version.go\"location:", err)
		os.Exit(1)
	}

	return versionFilepath
}
