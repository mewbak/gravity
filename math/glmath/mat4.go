package glmath

import (
	"bytes"
	"fmt"
	"math"
	"text/tabwriter"
)

// Mat4 represents a 4x4 matrix
type Mat4 [16]float32

// M4 ...
func M4() Mat4 {
	return Mat4{
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1,
	}
}

// TargetTo ...
func (m *Mat4) TargetTo(eye, target, up Vec3) Mat4 {
	x1, y1, z1 := eye[0], eye[1], eye[2]
	x2, y2, z2 := target[0], target[1], target[2]
	xUp, yUp, zUp := up[0], up[1], up[2]
	z0, z1, z2 := x1-x2, y1-y2, z1-z2
	length := z0*z0 + z1*z1 + z2*z2
	if length > 0 {
		length = 1 / float32(math.Sqrt(float64(length)))
		z0 *= length
		z1 *= length
		z2 *= length
	}

	a := yUp*z2 - zUp*z1
	b := zUp*z0 - xUp*z2
	c := xUp*z1 - yUp*z0

	length = a*a + b*b + c*c
	if length > 0 {
		length = 1 / float32(math.Sqrt(float64(length)))
		a *= length
		b *= length
		c *= length
	}

	return Mat4{
		a, b, c, 0,
		z1*b - z2*a, z2*a - z0*b, z0*b - z1*a, 0,
		z0, z1, z2, 0,
		x1, y1, z1, 1,
	}
}

// CreateInverse ...
func (m *Mat4) CreateInverse() *Mat4 {
	det := m.Determinant()
	if Equal(det, float32(0.0)) {
		return m
	}
	result := &Mat4{
		-m[7]*m[10]*m[13] + m[6]*m[11]*m[13] + m[7]*m[9]*m[14] - m[5]*m[11]*m[14] - m[6]*m[9]*m[15] + m[5]*m[10]*m[15],
		m[3]*m[10]*m[13] - m[2]*m[11]*m[13] - m[3]*m[9]*m[14] + m[1]*m[11]*m[14] + m[2]*m[9]*m[15] - m[1]*m[10]*m[15],
		-m[3]*m[6]*m[13] + m[2]*m[7]*m[13] + m[3]*m[5]*m[14] - m[1]*m[7]*m[14] - m[2]*m[5]*m[15] + m[1]*m[6]*m[15],
		m[3]*m[6]*m[9] - m[2]*m[7]*m[9] - m[3]*m[5]*m[10] + m[1]*m[7]*m[10] + m[2]*m[5]*m[11] - m[1]*m[6]*m[11],
		m[7]*m[10]*m[12] - m[6]*m[11]*m[12] - m[7]*m[8]*m[14] + m[4]*m[11]*m[14] + m[6]*m[8]*m[15] - m[4]*m[10]*m[15],
		-m[3]*m[10]*m[12] + m[2]*m[11]*m[12] + m[3]*m[8]*m[14] - m[0]*m[11]*m[14] - m[2]*m[8]*m[15] + m[0]*m[10]*m[15],
		m[3]*m[6]*m[12] - m[2]*m[7]*m[12] - m[3]*m[4]*m[14] + m[0]*m[7]*m[14] + m[2]*m[4]*m[15] - m[0]*m[6]*m[15],
		-m[3]*m[6]*m[8] + m[2]*m[7]*m[8] + m[3]*m[4]*m[10] - m[0]*m[7]*m[10] - m[2]*m[4]*m[11] + m[0]*m[6]*m[11],
		-m[7]*m[9]*m[12] + m[5]*m[11]*m[12] + m[7]*m[8]*m[13] - m[4]*m[11]*m[13] - m[5]*m[8]*m[15] + m[4]*m[9]*m[15],
		m[3]*m[9]*m[12] - m[1]*m[11]*m[12] - m[3]*m[8]*m[13] + m[0]*m[11]*m[13] + m[1]*m[8]*m[15] - m[0]*m[9]*m[15],
		-m[3]*m[5]*m[12] + m[1]*m[7]*m[12] + m[3]*m[4]*m[13] - m[0]*m[7]*m[13] - m[1]*m[4]*m[15] + m[0]*m[5]*m[15],
		m[3]*m[5]*m[8] - m[1]*m[7]*m[8] - m[3]*m[4]*m[9] + m[0]*m[7]*m[9] + m[1]*m[4]*m[11] - m[0]*m[5]*m[11],
		m[6]*m[9]*m[12] - m[5]*m[10]*m[12] - m[6]*m[8]*m[13] + m[4]*m[10]*m[13] + m[5]*m[8]*m[14] - m[4]*m[9]*m[14],
		-m[2]*m[9]*m[12] + m[1]*m[10]*m[12] + m[2]*m[8]*m[13] - m[0]*m[10]*m[13] - m[1]*m[8]*m[14] + m[0]*m[9]*m[14],
		m[2]*m[5]*m[12] - m[1]*m[6]*m[12] - m[2]*m[4]*m[13] + m[0]*m[6]*m[13] + m[1]*m[4]*m[14] - m[0]*m[5]*m[14],
		-m[2]*m[5]*m[8] + m[1]*m[6]*m[8] + m[2]*m[4]*m[9] - m[0]*m[6]*m[9] - m[1]*m[4]*m[10] + m[0]*m[5]*m[10],
	}
	return result.Multiply(1 / det)
}

// Invert ...
func (m *Mat4) Invert() *Mat4 {
	det := m.Determinant()
	if Equal(det, float32(0.0)) {
		return m
	}
	m[0] = -m[7]*m[10]*m[13] + m[6]*m[11]*m[13] + m[7]*m[9]*m[14] - m[5]*m[11]*m[14] - m[6]*m[9]*m[15] + m[5]*m[10]*m[15]
	m[1] = m[3]*m[10]*m[13] - m[2]*m[11]*m[13] - m[3]*m[9]*m[14] + m[1]*m[11]*m[14] + m[2]*m[9]*m[15] - m[1]*m[10]*m[15]
	m[2] = -m[3]*m[6]*m[13] + m[2]*m[7]*m[13] + m[3]*m[5]*m[14] - m[1]*m[7]*m[14] - m[2]*m[5]*m[15] + m[1]*m[6]*m[15]
	m[3] = m[3]*m[6]*m[9] - m[2]*m[7]*m[9] - m[3]*m[5]*m[10] + m[1]*m[7]*m[10] + m[2]*m[5]*m[11] - m[1]*m[6]*m[11]
	m[4] = m[7]*m[10]*m[12] - m[6]*m[11]*m[12] - m[7]*m[8]*m[14] + m[4]*m[11]*m[14] + m[6]*m[8]*m[15] - m[4]*m[10]*m[15]
	m[5] = -m[3]*m[10]*m[12] + m[2]*m[11]*m[12] + m[3]*m[8]*m[14] - m[0]*m[11]*m[14] - m[2]*m[8]*m[15] + m[0]*m[10]*m[15]
	m[6] = m[3]*m[6]*m[12] - m[2]*m[7]*m[12] - m[3]*m[4]*m[14] + m[0]*m[7]*m[14] + m[2]*m[4]*m[15] - m[0]*m[6]*m[15]
	m[7] = -m[3]*m[6]*m[8] + m[2]*m[7]*m[8] + m[3]*m[4]*m[10] - m[0]*m[7]*m[10] - m[2]*m[4]*m[11] + m[0]*m[6]*m[11]
	m[8] = -m[7]*m[9]*m[12] + m[5]*m[11]*m[12] + m[7]*m[8]*m[13] - m[4]*m[11]*m[13] - m[5]*m[8]*m[15] + m[4]*m[9]*m[15]
	m[9] = m[3]*m[9]*m[12] - m[1]*m[11]*m[12] - m[3]*m[8]*m[13] + m[0]*m[11]*m[13] + m[1]*m[8]*m[15] - m[0]*m[9]*m[15]
	m[10] = -m[3]*m[5]*m[12] + m[1]*m[7]*m[12] + m[3]*m[4]*m[13] - m[0]*m[7]*m[13] - m[1]*m[4]*m[15] + m[0]*m[5]*m[15]
	m[11] = m[3]*m[5]*m[8] - m[1]*m[7]*m[8] - m[3]*m[4]*m[9] + m[0]*m[7]*m[9] + m[1]*m[4]*m[11] - m[0]*m[5]*m[11]
	m[12] = m[6]*m[9]*m[12] - m[5]*m[10]*m[12] - m[6]*m[8]*m[13] + m[4]*m[10]*m[13] + m[5]*m[8]*m[14] - m[4]*m[9]*m[14]
	m[13] = -m[2]*m[9]*m[12] + m[1]*m[10]*m[12] + m[2]*m[8]*m[13] - m[0]*m[10]*m[13] - m[1]*m[8]*m[14] + m[0]*m[9]*m[14]
	m[14] = m[2]*m[5]*m[12] - m[1]*m[6]*m[12] - m[2]*m[4]*m[13] + m[0]*m[6]*m[13] + m[1]*m[4]*m[14] - m[0]*m[5]*m[14]
	m[15] = -m[2]*m[5]*m[8] + m[1]*m[6]*m[8] + m[2]*m[4]*m[9] - m[0]*m[6]*m[9] - m[1]*m[4]*m[10] + m[0]*m[5]*m[10]
	return m.Multiply(1 / det)
}

// Determinant ...
func (m *Mat4) Determinant() float32 {
	return m[0]*m[5]*m[10]*m[15] -
		m[0]*m[5]*m[11]*m[14] -
		m[0]*m[6]*m[9]*m[15] +
		m[0]*m[6]*m[11]*m[13] +
		m[0]*m[7]*m[9]*m[14] -
		m[0]*m[7]*m[10]*m[13] -
		m[1]*m[4]*m[10]*m[15] +
		m[1]*m[4]*m[11]*m[14] +
		m[1]*m[6]*m[8]*m[15] -
		m[1]*m[6]*m[11]*m[12] -
		m[1]*m[7]*m[8]*m[14] +
		m[1]*m[7]*m[10]*m[12] +
		m[2]*m[4]*m[9]*m[15] -
		m[2]*m[4]*m[11]*m[13] -
		m[2]*m[5]*m[8]*m[15] +
		m[2]*m[5]*m[11]*m[12] +
		m[2]*m[7]*m[8]*m[13] -
		m[2]*m[7]*m[9]*m[12] -
		m[3]*m[4]*m[9]*m[14] +
		m[3]*m[4]*m[10]*m[13] +
		m[3]*m[5]*m[8]*m[14] -
		m[3]*m[5]*m[10]*m[12] -
		m[3]*m[6]*m[8]*m[13] +
		m[3]*m[6]*m[9]*m[12]
}

// Multiply ...
func (m *Mat4) Multiply(f float32) *Mat4 {
	m[0] = m[0] * f
	m[1] = m[1] * f
	m[2] = m[2] * f
	m[3] = m[3] * f
	m[4] = m[4] * f
	m[5] = m[5] * f
	m[6] = m[6] * f
	m[7] = m[7] * f
	m[8] = m[8] * f
	m[9] = m[9] * f
	m[10] = m[10] * f
	m[11] = m[11] * f
	m[12] = m[12] * f
	m[13] = m[13] * f
	m[14] = m[14] * f
	m[15] = m[15] * f
	return m
}

func (m *Mat4) String() string {
	buf := new(bytes.Buffer)
	w := tabwriter.NewWriter(buf, 4, 4, 1, ' ', tabwriter.AlignRight)
	for row := 0; row < 4; row++ {
		for col := 0; col < 4; col++ {
			fmt.Fprintf(w, "%f\t", m[row+col*4])
		}
		fmt.Fprintln(w, "")
	}
	w.Flush()
	return buf.String()
}
